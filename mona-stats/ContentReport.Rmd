
---
title: "Massbank of North America - statistics"
author: "Gert Wohlgemuth"
date: '`r Sys.Date()`'
output:
  pdf_document:
    fig_height: 5
    fig_width: 5
    number_sections: yes
    toc: yes
    dev: pdf 
  html_document:
    number_sections: yes
    theme: journal
    toc: yes
  word_document:
    fig_caption: yes
    fig_height: 5
    fig_width: 5
---

```{r, include=FALSE}

local({r <- getOption("repos")
       r["CRAN"] <- "http://cran.r-project.org" 
       options(repos=r)
})

list.of.packages <- c("sqldf", "ggplot2","RPostgreSQL","gplots","pander","stringr","XML")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)


#loading initial data and libraries
library("sqldf")
library("ggplot2")
library("RPostgreSQL")
library("gplots")
library("pander")
library("stringr")
library("XML")

#configure database options
options(sqldf.RPostgreSQL.user ="compound", 
        sqldf.RPostgreSQL.password ="asdf",
        sqldf.RPostgreSQL.dbname ="monaproduction",
        sqldf.RPostgreSQL.host ="venus.fiehnlab.ucdavis.edu", 
        sqldf.RPostgreSQL.port =5432)

drv <- dbDriver("PostgreSQL")

sqldf("
      

CREATE OR REPLACE FUNCTION spectra_statistics_for_metadata(field IN text,count out bigint,value out text)
RETURNS setof record
AS $$

select
   count,
   value
from
   (  select
      count(*) as count,
      value
   from
      (  

   select
         distinct f.splash || inchi_key,
         h.string_value as value 
      from
         tag a,
         spectrum b,
         compound c,
         compound_link d,
         tag_link e,
         splash f, 
         meta_data g,
         meta_data_value h
      where
         f.spectrum_id = b.id
         and g.id = h.meta_data_id
         and h.owner_id = b.id
         and e.tag_id = a.id 
         and e.owner_id = b.id 
         and b.id = d.spectrum_id 
         and d.compound_id = c.id 
         and lower(g.name) = $1

  ) a 
   group by
      value  ) a  ;
               

$$ LANGUAGE sql;

      ")

sqldf("
create or replace function get_type(stringValue text) returns varchar as $$

begin
    begin
        begin
           if(stringValue::double precision is not null) then
            begin
                begin
                    if(stringValue::integer is not null) then
                        return 'integer';
                    end if;

               exception when numeric_value_out_of_range then
                    return 'long';
                end;
            exception when invalid_text_representation then
                return 'double';
            end;

            return 'double';

           elsif(stringValue::boolean is not null) then
                return 'boolean';
           else
                return 'string';    
           end if;       

        EXCEPTION when invalid_text_representation  then
            return 'string';
        end;
    exception when numeric_value_out_of_range then
        return 'unknown type';
    end;
end;

$$ language plpgsql
      
      ")
#listOfExternalDatabases <- c('HMDB','GNPS','MassBank','lipidblast','binbase')
listOfExternalDatabases <- c('MassBank','respect','gnps','lipidblast','FAHFA','HMDB')

#build a query to ensure the items are actually contained in the tag list and have been validated
listOfExternalDatabasesQuery = "select text from tag a, tag_link b, splash c where a.id = b.tag_id and b.owner_id = c.spectrum_id and lower(text) in ("

  for(db in listOfExternalDatabases){
        listOfExternalDatabasesQuery = paste( listOfExternalDatabasesQuery,"'",tolower(db),"'",',',sep = '')
  }
listOfExternalDatabasesQuery = substr(listOfExternalDatabasesQuery,1,nchar(listOfExternalDatabasesQuery)-1)

listOfExternalDatabasesQuery = paste(listOfExternalDatabasesQuery,") group by text",sep="")

listOfExternalDatabases = sort(sqldf(listOfExternalDatabasesQuery)$text)

```



#Introduction

MassBank of America (MoNA), is an auto curating repository for storing, comparing and querying mass spectra of chemical compounds. It is metadata centric and it was designed to allow easy integration into other tools by utilize its REST based application programming interface.

MoNA is utilizing the InChI Key as unique identifier for chemicals and is designed for easy scalability and expandability. This is realized by utilizing common applications like nginx, grails, AngularJS, postgresSQL and tomcat.

MoNA is currently integrated in applications like MSDial, BinBase, MZMine and the statistics package R. This was accomplished by utilizing its REST based API, which is also utilized by its main AngularJS based web interface. We consider MoNA to be highly useful for crosslinking mass spectra in publications, identification of unknowns and integration in data acquisition software.

This report, provides you with an overview of the content of the MoNA system and the sources of these data.

# Database content analysis

This secion of the report provides you with a simple overview of the content in MoNA.

\pagebreak

## Main database content providers

```{r,include=FALSE}

submittersInMona = sqldf("select count(*) from submitter")
spectraBySubmitter = sqldf("
select
   count(*),
   first_name as \"first name\",
   last_name as \"last name\",
   avg(scaled_score) as score 
from
   submitter a,
   spectrum b,
   splash c,
   score d 
where
   d.id = b.score_id 
   and a.id = b.submitter_id 
   and c.spectrum_id = b.id 
   and deleted = false 
group by
   first_name,
   last_name 
order by
   score desc,
   count desc                           
                           ")
```

Currently MoNA contains spectra from $`r submittersInMona`$ different submitters. These data have been automatically filtered, ranked, checked for common errors and enhanced with computed data.

```{r,echo=FALSE}
panderOptions("digits", 2)
pander(spectraBySubmitter)
```

\pagebreak

## Compounds in MoNA

```{r, include=FALSE}

monaUniqueCompounds = sqldf("select count(*) from compound")
externalIdCount = sqldf("select count(*) from meta_data_category a, meta_data b where a.name = 'external id' and b.category_id = a.id")
derivatizationProduct = sqldf("select count(*) from compound_link a, spectrum b  where a.spectrum_id = b.id and b.deleted = false and type = 'PREDICTED'")
```

These submissions of the provided spectra, resulted in $`r monaUniqueCompounds`$ Chemical compounds in the database, which were automatically associated with $`r externalIdCount`$ different external database identifier. The chemical translation service was utilized to generate these associations.

During the curation workflow, MoNA also successfully predicted the derivatization product for $`r derivatizationProduct`$ GCMS spectra.

## Predicted vs Experimental Spectra

MoNA contains different kinds of spectra and this contains predicted as well as experimentally aquired spectra. These experimental spectra can be obtained by utilizing standards or alternativly being 'picked'.

```{r,include=FALSE}
experimentalVsPredictedSpectraReport=sqldf("

select
   * 
from
   (  select
      count(*) as count,
      text as database 
   from
      (   select
         distinct f.splash || inchi_key,
         text 
      from
         tag a,
         spectrum b,
         compound c,
         compound_link d,
         tag_link e,
         splash f 
      where
         f.spectrum_id = b.id 
         and e.tag_id = a.id 
         and e.owner_id = b.id 
         and b.id = d.spectrum_id 
         and d.compound_id = c.id 
         and lower(text) in (
            'experimental','virtual' 
         )   ) a 
   group by
      text  ) a  
   union
   select
      (select
         count(*) 
      from
         spectrum a,
         splash b 
      where
         a.id = b.spectrum_id)     - count(*) as count,
      'unknown' 
   from
      (   select
         distinct f.splash || inchi_key,
         text 
      from
         tag a,
         spectrum b,
         compound c,
         compound_link d,
         tag_link e,
         splash f 
      where
         f.spectrum_id = b.id 
         and e.tag_id = a.id 
         and e.owner_id = b.id 
         and b.id = d.spectrum_id 
         and d.compound_id = c.id 
         and lower(text) in (
            'experimental','virtual' 
         )   ) a")


```


```{r,echo=FALSE,fig.width=5, fig.height=3, fig.align='center'}
qplot(data=experimentalVsPredictedSpectraReport,x=experimentalVsPredictedSpectraReport$database,y=experimentalVsPredictedSpectraReport$count,geom="bar",stat="identity",xlab="type of spectra",ylab="count of spectra") + theme_bw()+ theme(axis.text.x = element_text(angle = 90, hjust = 1))+ coord_flip()
```

Sadly this information, was not provided for every available spectrum in the system.

\pagebreak

## Integration of external spectral databases

```{r, include=FALSE}

qr = "
select
   count(*) as count,
   text as database 
from
   (   select
      distinct f.splash || inchi_key,
      text 
   from
      tag a,
      spectrum b,
      compound c,
      compound_link d,
      tag_link e,
      splash f 
   where
      f.spectrum_id = b.id 
      and e.tag_id = a.id 
      and e.owner_id = b.id 
      and b.id = d.spectrum_id 
      and d.compound_id = c.id 
      and lower(text) in (
         
"

for( i in seq_along(listOfExternalDatabases)){ qr <- paste(qr,"'",tolower(listOfExternalDatabases[i]),"'",",",sep="" ) }
qr = substr(qr,1,nchar(qr)-1)
qr = paste(qr,')) a group by text')
spectraCountForDatabases = sqldf(qr)

```

Since MoNA was designed a system holding millions of spectra, we successfully integrated several external databases. This includes databases like $`r listOfExternalDatabases`$ and others. 

```{r,echo=FALSE,fig.width=5, fig.height=2.5, fig.align='center'}
qplot(data=spectraCountForDatabases,x=spectraCountForDatabases$database,y=spectraCountForDatabases$count,geom="bar",stat="identity",xlab="origin",ylab="count of spectra") + theme_bw()+ theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

```{r,echo=FALSE,fig.width=5, fig.height=3, fig.align='center'}
panderOptions("digits", 2)
pander(spectraCountForDatabases)
```

### Overlap of exiting databases

Since public database are merged into each other regularily, there will always some overlap between these sources, utilizing the SPLASH, we were able to easily visualize and identify spectra, unique to only one resource.

```{r,include=FALSE}

for(d in listOfExternalDatabases){
  qr = "

select
   distinct f.splash || inchi_key as key,
   text 
from
   tag a,
   spectrum b,
   compound c,
   compound_link d,
   tag_link e,
   splash f 
where
   f.spectrum_id = b.id 
   and e.tag_id = a.id 
   and e.owner_id = b.id 
   and b.id = d.spectrum_id 
   and d.compound_id = c.id 
   and lower(text) =

  "
  qr = paste(qr,"'",tolower(d),"'",sep="")
  assign(str_trim(paste('database_overlap',tolower(d),sep="_")),sqldf(qr))
  
  qr

}


```



```{r, echo=FALSE,fig.width=7, fig.height=7, fig.align='center'}
#provide us with one venn diagram containing all the databases in it
if(length(listOfExternalDatabases) <= 5){
  
  myList = list()
  
  for(db in listOfExternalDatabases){
        myList[[length(myList)+1]] = get(paste('database_overlap',tolower(db),sep='_'))$key
  }

  names(myList) <- unlist(listOfExternalDatabases)
          
  
  venn( 
    myList
  )
}
```

These detailed plots, provide you with a quick overview of the overlap, between all registered databases.


```{r, echo=FALSE,fig.width=2, fig.height=2}

#layout(matrix(c(1,1), ncol=3), width=c(2,2))

countOfVennPlots = length(listOfExternalDatabases) * length(listOfExternalDatabases) - length(listOfExternalDatabases)
mat <- matrix(1:countOfVennPlots, nrow = 2, ncol = countOfVennPlots/2, by = F)
par(mar=c(0,0,0,0))

for(i in 1:(length(listOfExternalDatabases)-1)){
  d = listOfExternalDatabases[i]
  for(j in (i+1):length(listOfExternalDatabases)){

    d2 = listOfExternalDatabases[j]
    
    if(d != d2){
        myList = list()
        
        myList[[1]] = get(paste('database_overlap',tolower(d),sep='_'))$key
        myList[[2]] = get(paste('database_overlap',tolower(d2),sep='_'))$key
        
        myList
        
        names(myList) <- c(d,d2)

        
          venn( 
            myList
          )
    }
  }
}
```

\pagebreak

### Submission of duplicated spectra

Due to the concept of merging several databases, MoNA ended up containing several duplicated spectra. These were automatically identified and flagged internally for removal by utilizing the Splash and InChI Key in combination. This combination ensures that identical spectra, which are associated with several different compounds will not be removed.

```{r,include=FALSE}
deletedSpectraReport=sqldf("select count(splash) as num, deleted from spectrum a, splash b where a.id = b.spectrum_id group by deleted")
duplicatedSpectraReport=sqldf("
select
   total,
   uniqueSpectra,
   total - uniqueSpectra as duplicated 
from
   (  select
      (select
         count(*) 
      from
         spectrum a,
         splash b 
      where
         a.id = b.spectrum_id) as total,
      (select
         count(distinct (c.inchi_key || splash)) 
      from
         splash a,
         compound_link b,
         compound c 
      where
         a.spectrum_id = b.spectrum_id 
         and b.compound_id = c.id) as uniqueSpectra ) a
                              ")
```


```{r,echo=FALSE, fig.width=7,fig.height=3}

qplot(data=duplicatedSpectraReport,x=c('total','uniquespectra','duplicated'),y=c(duplicatedSpectraReport$total,duplicatedSpectraReport$uniquespectra,duplicatedSpectraReport$duplicated),geom="bar",stat="identity",xlab="spectra",ylab="count of spectra") + theme_bw()+ theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  coord_flip()

```

```{r,echo=FALSE}
panderOptions("digits", 1)
pander(duplicatedSpectraReport)
```

### Distribution of spectra ion counts

This is a rough overview of the count of ion's, a spectrum has in MoNA.

```{r,include=FALSE}

spectraIonDistribution = sqldf("

select
   distinct splash || '-' || inchi,
   ionCount 
from
   (select
      count(*) as ionCount,
      spectrum_id 
   from
      ion  
   group by
      spectrum_id ) a,
   splash b,
   compound_link c,
   compound d 
where
   a.spectrum_id = b.spectrum_id 
   and b.spectrum_id = c.spectrum_id 
   and c.compound_id = d.id
                                                       ")
```

```{r, echo=FALSE ,fig.width=7, fig.height=4, fig.align='center'}

ggplot(data=spectraIonDistribution, aes(spectraIonDistribution$ioncount)) + geom_histogram(breaks=seq(0,100), aes(fill=..count..))  + theme_bw()+ ggtitle("distribution of spectra ion counts") +
    scale_fill_gradient("Count of spectra", low = "gray", high = "black") + labs(x="count of ions", y = "count")
```

## Data aquisition

This is lining out the different methods of data aquisition in MoNA.

### Aquisition Method

The spectra in MoNA, were aquirced utilzing several different types of chromatography methods.

```{r,include=FALSE}
aquistionMethodReport=sqldf("


select
   * 
from
   (  select
      count(*) as count,
      text as method 
   from
      (   select
         distinct f.splash || inchi_key,
         text 
      from
         tag a,
         spectrum b,
         compound c,
         compound_link d,
         tag_link e,
         splash f 
      where
         f.spectrum_id = b.id 
         and e.tag_id = a.id 
         and e.owner_id = b.id 
         and b.id = d.spectrum_id 
         and d.compound_id = c.id 
         and lower(text) in (
            'lcms','gcms' 
         )   
     ) a 
   group by
      text  ) a  
   union
   select
      (select
         count(distinct splash || inchi_key) 
      from
         spectrum a,
         splash b,
         compound c,
         compound_link d
      where
         c.id = d.compound_id and
         d.spectrum_id = a.id and
         a.id = b.spectrum_id) - count(*) as count,
      'other methods' 
   from
      (   
        select
          distinct f.splash || inchi_key
        from
          tag a,
          spectrum b,
          compound c,
          compound_link d,
          tag_link e,
          splash f 
        where
          f.spectrum_id = b.id 
          and e.tag_id = a.id 
          and e.owner_id = b.id 
          and b.id = d.spectrum_id 
          and d.compound_id = c.id 
          and lower(text) in (
            'lcms','gcms' 
          )   
        ) a
")


```


```{r,echo=FALSE,fig.width=7, fig.height=4, fig.align='center'}
qplot(data=aquistionMethodReport,x=aquistionMethodReport$method,y=aquistionMethodReport$count,geom="bar",stat="identity",xlab="aquisition method",ylab="count of spectra") + theme_bw()+ theme(axis.text.x = element_text(angle = 90, hjust = 1))+ coord_flip()
```


### MS Level

Currently MoNA contains mostly MS Spectra, which have been aquirred using different MS Levels. This will provide you with an rough overview.

```{r,include=FALSE}

msLevelTypeReport = sqldf("

select
   * 
from
   (  select
      count(*) as count,
      value
   from
      (  

   select
         distinct f.splash || inchi_key,
         h.string_value as value 
      from
         tag a,
         spectrum b,
         compound c,
         compound_link d,
         tag_link e,
         splash f, 
         meta_data g,
         meta_data_value h
      where
         f.spectrum_id = b.id
         and g.id = h.meta_data_id
         and h.owner_id = b.id
         and e.tag_id = a.id 
         and e.owner_id = b.id 
         and b.id = d.spectrum_id 
         and d.compound_id = c.id 
         and lower(g.name) = 'ms level'

  ) a 
   group by
      value  ) a  
   union
   select
       (select
         count(distinct splash || inchi_key) 
      from
         spectrum a,
         splash b,
         compound c,
         compound_link d
      where
         c.id = d.compound_id and
         d.spectrum_id = a.id and
         a.id = b.spectrum_id) - count(*) as count,
      'other spectra' 
   from
      (   select
         distinct f.splash || inchi_key
      from
         tag a,
         spectrum b,
         compound c,
         compound_link d,
         tag_link e,
         splash f, 
         meta_data g,
         meta_data_value h
      where
         f.spectrum_id = b.id
         and g.id = h.meta_data_id
         and h.owner_id = b.id
         and e.tag_id = a.id 
         and e.owner_id = b.id 
         and b.id = d.spectrum_id 
         and d.compound_id = c.id 
         and lower(g.name) = 'ms level'
    ) a
 

                          
                          ")
```

```{r,echo=FALSE,fig.width=7, fig.height=4, fig.align='center'}
qplot(data=msLevelTypeReport,x=msLevelTypeReport$value,y=msLevelTypeReport$count,geom="bar",stat="identity",xlab="MS Type",ylab="count of spectra") + theme_bw()+ theme(axis.text.x = element_text(angle = 90, hjust = 1)) + coord_flip()
```

### Ion Mode

Spectra can be aquired in different modes and this section of the report, provides you with a quick overview of these.

```{r,include=FALSE}

ionModeReport = sqldf("

select
   * 
from
   (  select
      count(*) as count,
      value
   from
      (  

   select
         distinct f.splash || inchi_key,
         h.string_value as value 
      from
         tag a,
         spectrum b,
         compound c,
         compound_link d,
         tag_link e,
         splash f, 
         meta_data g,
         meta_data_value h
      where
         f.spectrum_id = b.id
         and g.id = h.meta_data_id
         and h.owner_id = b.id
         and e.tag_id = a.id 
         and e.owner_id = b.id 
         and b.id = d.spectrum_id 
         and d.compound_id = c.id 
         and lower(g.name) = 'ion mode'

  ) a 
   group by
      value  ) a  
   union
   select
       (select
         count(distinct splash || inchi_key) 
      from
         spectrum a,
         splash b,
         compound c,
         compound_link d
      where
         c.id = d.compound_id and
         d.spectrum_id = a.id and
         a.id = b.spectrum_id) - count(*) as count,
      'other' 
   from
      (   select
         distinct f.splash || inchi_key
      from
         tag a,
         spectrum b,
         compound c,
         compound_link d,
         tag_link e,
         splash f, 
         meta_data g,
         meta_data_value h
      where
         f.spectrum_id = b.id
         and g.id = h.meta_data_id
         and h.owner_id = b.id
         and e.tag_id = a.id 
         and e.owner_id = b.id 
         and b.id = d.spectrum_id 
         and d.compound_id = c.id 
         and lower(g.name) = 'ion mode'
    ) a
 

                          
                          ")
```

```{r,echo=FALSE,fig.width=7, fig.height=4, fig.align='center'}
qplot(data=ionModeReport,x=ionModeReport$value,y=ionModeReport$count,geom="bar",stat="identity",xlab="Ion Mode",ylab="count of spectra") + theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + coord_flip()
```

### Precursor Types


```{r,include=FALSE}

precursorTypeReport = sqldf("
  select count, value from spectra_statistics_for_metadata('precursor type')
                          ")
```

```{r,echo=FALSE,fig.width=7, fig.height=8, fig.align='center'}
qplot(data=precursorTypeReport,x=precursorTypeReport$value,y=precursorTypeReport$count,geom="bar",stat="identity",xlab="Precursor Type",ylab="count of spectra") + theme_bw()+ theme(axis.text.x = element_text(angle = 90, hjust = 1)) + coord_flip()
```

### Derivatisation

Since none all spectra observed in GCMS are volatile or stable enough in their volatile form. They need to be derivatized. For this reason, you can utilize different reagents. This report provides you with an overview of the different utilized derivative types.


```{r,include=FALSE}

derivativeTypeReport = sqldf("

    select * from spectra_statistics_for_metadata('derivative type')

                          ")
```

```{r,echo=FALSE,fig.width=7, fig.height=8, fig.align='center'}
qplot(data=derivativeTypeReport,x=derivativeTypeReport$value,y=derivativeTypeReport$count,geom="bar",stat="identity",xlab="Derivative Type",ylab="count of spectra") + theme_bw()+ theme(axis.text.x = element_text(angle = 90, hjust = 1)) + coord_flip()
```


### Instrument

```{r,include=FALSE}

instrumentTypeReport = sqldf("
  select * from spectra_statistics_for_metadata('instrument type')
")
```

```{r,echo=FALSE,fig.width=7, fig.height=8, fig.align='center'}
qplot(data=instrumentTypeReport,x=instrumentTypeReport$value,y=instrumentTypeReport$count,geom="bar",stat="identity",xlab="Instrument Type",ylab="count of spectra") + theme_bw()+ theme(axis.text.x = element_text(angle = 90, hjust = 1)) + coord_flip()
```

## Usage of Labels and Tags

MoNA user the concept of tags of labels internally to mark certain spectra, having certain criteria. A quick overview of these tags can be found here.

```{r,include=FALSE}
tagsDistribtution = sqldf("
select count(*) as count ,text as value from tag a, tag_link b, splash d where a.id = b.tag_id and b.owner_id = d.spectrum_id group by text
                         ")
```


```{r,echo=FALSE,fig.width=7, fig.height=8, fig.align='center'}
qplot(data=tagsDistribtution,x=tagsDistribtution$value,y=tagsDistribtution$count,geom="bar",stat="identity",xlab="Tag/Label",ylab="count of spectra") + theme_bw()+ theme(axis.text.x = element_text(angle = 90, hjust = 1)) + coord_flip()
```


# MoNA Usage

This section will provide you with an overview, who is using MoNA and how often.

```{r,include=FALSE}


u = 'http://mona.fiehnlab.ucdavis.edu/statistics/'
tables = readHTMLTable(u)
monthlyVisitors = tables[[7]]

#assign header row
#cut unimportant rows
monthlyVisitors = monthlyVisitors[-c(1,2,3,4,16),]

colnames(monthlyVisitors)[1] = "Month"
colnames(monthlyVisitors)[2] = "Unique Vistors"
colnames(monthlyVisitors)[3] = "Number of Visits"
colnames(monthlyVisitors)[4] = "Pages"
colnames(monthlyVisitors)[5] = "Hits"
colnames(monthlyVisitors)[6] = "Bandwith"

#cut not longer needed columns
monthlyVisitors = monthlyVisitors[c(1,2,3,4,5,6)]

```

```{r,echo=FALSE,fig.width=7, fig.height=3, fig.align='center'}
ggplot(data=monthlyVisitors, aes(x=factor(monthlyVisitors$Month, levels=unique(monthlyVisitors$Month)), y = Hits)) + geom_bar(stat="identity", aes(fill=factor(`Unique Vistors`))) + xlab("month of the year") + ylab("page hits") + scale_fill_manual("Unique Visitors",values=gray.colors(12, start = 0.3, end = 0.9, gamma = 2.2, alpha = NULL)) + theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_x_discrete(expand = c(0, 0))+ scale_y_discrete(expand = c(0, 0))
```

```{r,echo=FALSE,fig.width=7, fig.height=3, fig.align='center'}
panderOptions("digits", 0)
pander(monthlyVisitors[c(1,2,3,5,6)], split.table = Inf)
```


# Database Performance Report

In this section, we will show an overview of the current performance of the MoNA system.

## Import Performance

During the import phase of the system, spectra will be associated with provided meta data, link to existing compound or create new compounds and undergo a rough filtering, to ensure that they are not duplicated spectra.

```{r, include=FALSE}

importStatistics = sqldf("select * from statistics where category = 'import'")
importPerformanceByWeek = sqldf("select count(value),avg(value), min(value), max(value),stddev(value),date_trunc('day', a.date_created)  as date  from statistics a where category = 'import' group by date order by date desc limit 30")
```

```{r,echo=FALSE,fig.width=7, fig.height=3, fig.align='center'}

ggplot(data=importStatistics,aes(x= value)) + geom_histogram(binwidth=100, fill=NA,color="black") + xlim(0,10000) + xlab("duration in ms") + ylab("count of imports")+ theme_bw() 

```


```{r,echo=FALSE,fig.width=7, fig.height=3, fig.align='center'}

ggplot(data=importPerformanceByWeek,aes(x= date,y=avg,fill=factor(importPerformanceByWeek$count))) + geom_bar(stat = "identity", position="dodge") + xlab("day") + ylab("average time in ms")+ theme_bw() + ggtitle("import speed over the last 30 days")  + scale_fill_manual("Imported spectra",values=gray.colors(12, start = 0.3, end = 0.9, gamma = 2.2, alpha = NULL)) 

```



Current estimates, based on the observed performance allow us to predict that the system can import $`r 24*60*60*1000/mean(importStatistics$value)`$ spectra in a single day.

## Validation Performance


Once the import is complete, the system automatically validates the imported spectra, computes additional meta data, synchronizes it with the Chemical Translation Service and computes Splashes, for an improved similarity search.

```{r, include=FALSE}
validationPerformanceByWeek = sqldf("select count(value),avg(value), min(value), max(value),stddev(value),date_trunc('day', a.date_created)  as date  from statistics a where category = 'validation' group by date order by date desc limit 30")

validationStatistics = sqldf("select * from statistics where category = 'validation'")
```

```{r,echo=FALSE,fig.width=7, fig.height=3, fig.align='center'}

ggplot(data=validationStatistics,aes(x= value)) + geom_histogram(binwidth=150, fill=NA,color="black") + xlim(0,15000) + xlab("duration in ms") + ylab("count of validations")+ theme_bw() 

```


```{r,echo=FALSE,fig.width=7, fig.height=3, fig.align='center'}

ggplot(data=validationPerformanceByWeek,aes(x= date,y=avg,fill=factor(validationPerformanceByWeek$count))) + geom_bar(stat = "identity", position="dodge") + xlab("day") + ylab("average time in ms")+ theme_bw() + ggtitle("validation speed over the last 30 days")  + scale_fill_manual("validated spectra",values=gray.colors(12, start = 0.3, end = 0.9, gamma = 2.2, alpha = NULL)) 

```


Current estimates, based on the observed performance allow us to predict that the system can validate $`r 24*60*60*1000/mean(validationStatistics$value)`$ spectra in a single day.


## Scoring Perfomance

Once the validation is complete, the system automatically scores the received spectra, based on it's metadata and the correctness of these data, as well as there association with other metdata.

```{r, include=FALSE}

scoringStatistics = sqldf("select * from statistics where category = 'scoring'")
```

```{r,echo=FALSE,fig.width=7, fig.height=3, fig.align='center'}

ggplot(data=scoringStatistics,aes(x= value)) + geom_histogram(binwidth=50, fill=NA,color="black") + xlim(0,5000) + xlab("duration in ms") + ylab("count of scorings")+ theme_bw() 

```

Current estimates, based on the observed performance allow us to predict that the system can score $`r 24*60*60*1000/mean(scoringStatistics$value)`$ spectra in a single day.

# Internal Diagnostics

This are MoNa internal statsitics and mostly useful for developing and debugging the system.

## Splash Distribution

A quick overview, of the distrubtion of the spectral histograms. This allows us to tune algorithms and queries.

```{r,include=FALSE}

histogramDistribution = sqldf("
    select count(*)::integer, block2::text from splash group by block2 order by count desc limit 10
")

```

```{r, echo=FALSE}
set.caption("most observered histograms, limited to 10")
panderOptions("digits", 2)
pander(histogramDistribution)
```

The utilized similarity search algorithm, is usually the quickest, if we only have 3000-5000 identical histograms.

## Data type association

The current system contains hundred of diffrent meta data types and to optimize the rule based autocuration system, we are utilizing this report to adjust the data types accordingly. If you see more than 1 datatype on a bar in the chart, that means that we need to adjust our rules and interpret the data better.

```{r,include=FALSE}
metaDataTypeReport = sqldf("
        select get_type(string_value) as type, count(*) as count,b.name from meta_data_value a, meta_data b, meta_data_category c where a.meta_data_id = b.id and b.category_id = c.id and lower(c.name) not in ( 'annotation' ,'external id') group by get_type(string_value), b.name                          
            
                           ")

```



```{r,echo=FALSE,fig.width=8, fig.height=10, fig.align='center'}

qplot(data=split(metaDataTypeReport,1:2)[[1]],x=name,y=count,geom="bar",stat="identity",xlab="Meta Data Type",ylab="count of values", fill=type)+ theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + coord_flip()

```

```{r,echo=FALSE,fig.width=8, fig.height=10, fig.align='center'}

qplot(data=split(metaDataTypeReport,1:2)[[2]],x=name,y=count,geom="bar",stat="identity",xlab="Meta Data Type",ylab="count of values", fill=type)+ theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + coord_flip()+ theme(axis.ticks = element_blank())

```

## Similar named meta data names

This provides us with a quick overview of possible duplicated meta data names, which allows us to adjust the rules and filter these values during the next validation cycle. The graphs have been split into several sub graphs, to allow an easier presentation of the data and enhance readability.

```{r,include=FALSE}


duplicatedMetaDataReport = sqldf("

select count(*) as count ,a,b,sim,sim * count(*) as score, case when substring(lower(a),1) < 'd' then 'one' when substring(lower(a),1) between 'd'  and 'l' then 'two' when substring(lower(a),1) between 'm' and  'q' then 'three' else 'four' end as part from (

select a.name as a, b.name as b, similarity(a.name,b.name) as sim,a.id from meta_data a, meta_data b, meta_data_category c where a.name < b.name and c.id = a.category_id and c.id = b.category_id and lower(c.name) not in ('annotation','external id') and similarity(a.name, b.name) > 0.15 order by sim desc, a.name, b.name
 )a,
meta_data_value b where b.meta_data_id = a.id group by a,b,sim, part


                                 
")


duplicatedMetaDataReportSplit = split(duplicatedMetaDataReport,duplicatedMetaDataReport$part)

```

```{r,echo=FALSE}
panderOptions('digits', 2)

set.caption("Top 10 metadata name similarity pairs, with associated count")

duplicatedMetaDataReportSubSet = head(duplicatedMetaDataReport[with(duplicatedMetaDataReport,order(-count)),],10)[,1:4]
row.names(duplicatedMetaDataReportSubSet) <-NULL
pander(duplicatedMetaDataReportSubSet)

```

```{r,echo=FALSE,fig.width=8,fig.height=10,fig.align='center'}
ggplot(duplicatedMetaDataReportSplit[[1]], aes(a,b)) + theme_bw() + geom_tile(aes(fill = sim), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue", name = "similarity") + xlab("meta data name") + ylab("meta data name") + theme(axis.text.x = element_text(angle = 90, hjust = 1))+ scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + theme(axis.ticks = element_blank())
```
 

```{r,echo=FALSE,fig.width=8,fig.height=10,fig.align='center'}
ggplot(duplicatedMetaDataReportSplit[[2]], aes(a,b))  + theme_bw()+ geom_tile(aes(fill = sim), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue", name = "similarity") + xlab("meta data name") + ylab("meta data name") + theme(axis.text.x = element_text(angle = 90, hjust = 1))+ scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + theme(axis.ticks = element_blank())
```

```{r,echo=FALSE,fig.width=8,fig.height=10,fig.align='center'}
ggplot(duplicatedMetaDataReportSplit[[3]], aes(a,b))  + theme_bw()+ geom_tile(aes(fill = sim), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue", name = "similarity") + xlab("meta data name") + ylab("meta data name") + theme(axis.text.x = element_text(angle = 90, hjust = 1))+ scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + theme(axis.ticks = element_blank())
```

```{r,echo=FALSE,fig.width=8,fig.height=10,fig.align='center'}
ggplot(duplicatedMetaDataReportSplit[[4]], aes(a,b)) + theme_bw() + geom_tile(aes(fill = sim), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue", name = "similarity") + xlab("meta data name") + ylab("meta data name") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + theme(axis.ticks = element_blank())
```

 
 